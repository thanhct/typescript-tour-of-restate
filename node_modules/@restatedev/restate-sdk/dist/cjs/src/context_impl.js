"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextImpl = void 0;
const errors_js_1 = require("./types/errors.js");
const rpc_js_1 = require("./types/rpc.js");
const restate_sdk_core_1 = require("@restatedev/restate-sdk-core");
const rand_js_1 = require("./utils/rand.js");
class ContextImpl {
    coreVm;
    input;
    console;
    handlerKind;
    invocationEndPromise;
    inputReader;
    outputWriter;
    invocationRequest;
    rand;
    date = {
        now: () => {
            return this.run(() => Date.now());
        },
        toJSON: () => {
            return this.run(() => new Date().toJSON());
        },
    };
    currentRead;
    constructor(coreVm, input, console, handlerKind, attemptHeaders, extraArgs, invocationEndPromise, inputReader, outputWriter) {
        this.coreVm = coreVm;
        this.input = input;
        this.console = console;
        this.handlerKind = handlerKind;
        this.invocationEndPromise = invocationEndPromise;
        this.inputReader = inputReader;
        this.outputWriter = outputWriter;
        this.invocationRequest = {
            id: input.invocation_id,
            headers: input.headers.reduce((headers, { key, value }) => {
                headers.set(key, value);
                return headers;
            }, new Map()),
            attemptHeaders: Object.entries(attemptHeaders).reduce((headers, [key, value]) => {
                if (value !== undefined) {
                    headers.set(key, value instanceof Array ? value[0] : value);
                }
                return headers;
            }, new Map()),
            body: input.input,
            extraArgs,
        };
        this.rand = new rand_js_1.RandImpl(input.invocation_id, () => {
            if (coreVm.is_inside_run()) {
                throw new Error("Cannot generate random numbers within a run closure. Use the random object outside the run closure.");
            }
        });
    }
    get key() {
        switch (this.handlerKind) {
            case rpc_js_1.HandlerKind.EXCLUSIVE:
            case rpc_js_1.HandlerKind.SHARED:
            case rpc_js_1.HandlerKind.WORKFLOW: {
                return this.input.key;
            }
            default:
                throw new errors_js_1.TerminalError("this handler type doesn't support key()");
        }
    }
    request() {
        return this.invocationRequest;
    }
    get(name, serde) {
        return this.processCompletableEntry((vm) => vm.sys_get_state(name), (asyncResultValue) => {
            if (asyncResultValue === "Empty") {
                // Empty
                return null;
            }
            else if ("Success" in asyncResultValue) {
                return (serde ?? (0, rpc_js_1.defaultSerde)()).deserialize(asyncResultValue.Success);
            }
            else if ("Failure" in asyncResultValue) {
                throw new errors_js_1.TerminalError(asyncResultValue.Failure.message, {
                    errorCode: asyncResultValue.Failure.code,
                });
            }
            throw new Error(`Unexpected variant in async result: ${JSON.stringify(asyncResultValue)}`);
        });
    }
    stateKeys() {
        return this.processCompletableEntry((vm) => vm.sys_get_state_keys(), (asyncResultValue) => {
            if (typeof asyncResultValue === "object" &&
                "StateKeys" in asyncResultValue) {
                return asyncResultValue.StateKeys;
            }
            else if (typeof asyncResultValue === "object" &&
                "Failure" in asyncResultValue) {
                throw new errors_js_1.TerminalError(asyncResultValue.Failure.message, {
                    errorCode: asyncResultValue.Failure.code,
                });
            }
            throw new Error(`Unexpected variant in async result: ${JSON.stringify(asyncResultValue)}`);
        });
    }
    set(name, value, serde) {
        this.processNonCompletableEntry((vm) => vm.sys_set_state(name, (serde ?? (0, rpc_js_1.defaultSerde)()).serialize(value)));
    }
    clear(name) {
        this.processNonCompletableEntry((vm) => vm.sys_clear_state(name));
    }
    clearAll() {
        this.processNonCompletableEntry((vm) => vm.sys_clear_all_state());
    }
    // --- Calls, background calls, etc
    //
    genericCall(call) {
        const requestSerde = call.inputSerde ?? restate_sdk_core_1.serde.binary;
        const responseSerde = call.outputSerde ?? restate_sdk_core_1.serde.binary;
        return this.processCompletableEntry((vm) => {
            const parameter = requestSerde.serialize(call.parameter);
            return vm.sys_call(call.service, call.method, parameter, call.key);
        }, (asyncResultValue) => {
            if (typeof asyncResultValue === "object" &&
                "Success" in asyncResultValue) {
                return responseSerde.deserialize(asyncResultValue.Success);
            }
            else if (typeof asyncResultValue === "object" &&
                "Failure" in asyncResultValue) {
                throw new errors_js_1.TerminalError(asyncResultValue.Failure.message, {
                    errorCode: asyncResultValue.Failure.code,
                });
            }
            throw new Error(`Unexpected variant in async result: ${JSON.stringify(asyncResultValue)}`);
        });
    }
    genericSend(send) {
        this.processNonCompletableEntry((vm) => {
            const requestSerde = send.inputSerde ?? restate_sdk_core_1.serde.binary;
            const parameter = requestSerde.serialize(send.parameter);
            let delay;
            if (send.delay !== undefined) {
                delay = BigInt(send.delay);
            }
            vm.sys_send(send.service, send.method, parameter, send.key, delay);
        });
    }
    serviceClient({ name }) {
        return (0, rpc_js_1.makeRpcCallProxy)((call) => this.genericCall(call), name);
    }
    objectClient({ name }, key) {
        return (0, rpc_js_1.makeRpcCallProxy)((call) => this.genericCall(call), name, key);
    }
    workflowClient({ name }, key) {
        return (0, rpc_js_1.makeRpcCallProxy)((call) => this.genericCall(call), name, key);
    }
    serviceSendClient({ name }, opts) {
        return (0, rpc_js_1.makeRpcSendProxy)((send) => this.genericSend(send), name, undefined, opts?.delay);
    }
    objectSendClient({ name }, key, opts) {
        return (0, rpc_js_1.makeRpcSendProxy)((send) => this.genericSend(send), name, key, opts?.delay);
    }
    workflowSendClient({ name }, key, opts) {
        return (0, rpc_js_1.makeRpcSendProxy)((send) => this.genericSend(send), name, key, opts?.delay);
    }
    // DON'T make this function async!!!
    // The reason is that we want the errors thrown by the initial checks to be propagated in the caller context,
    // and not in the promise context. To understand the semantic difference, make this function async and run the
    // UnawaitedSideEffectShouldFailSubsequentContextCall test.
    run(nameOrAction, actionSecondParameter, options) {
        const { name, action } = unpack(nameOrAction, actionSecondParameter);
        const serde = options?.serde ?? (0, rpc_js_1.defaultSerde)();
        try {
            const runEnterResult = this.coreVm.sys_run_enter(name || "");
            // Check if the run was already executed
            if (typeof runEnterResult === "object" &&
                "ExecutedWithSuccess" in runEnterResult) {
                return Promise.resolve(serde.deserialize(runEnterResult.ExecutedWithSuccess));
            }
            else if (typeof runEnterResult === "object" &&
                "ExecutedWithFailure" in runEnterResult) {
                return Promise.reject(new errors_js_1.TerminalError(runEnterResult.ExecutedWithFailure.message, {
                    errorCode: runEnterResult.ExecutedWithFailure.code,
                }));
            }
        }
        catch (e) {
            this.handleInvocationEndError(e);
            return pendingPromise();
        }
        // We wrap the rest of the execution in this closure to create a future
        const doRun = async () => {
            const startTime = Date.now();
            let res;
            let err;
            try {
                res = await action();
            }
            catch (e) {
                err = (0, errors_js_1.ensureError)(e);
            }
            const attemptDuration = Date.now() - startTime;
            // Record the result/failure, get back the handle for the ack.
            let handle;
            try {
                if (err !== undefined) {
                    if (err instanceof errors_js_1.TerminalError) {
                        // Record failure, go ahead
                        handle = this.coreVm.sys_run_exit_failure({
                            code: err.code,
                            message: err.message,
                        });
                    }
                    else {
                        if (options?.retryIntervalFactor === undefined &&
                            options?.initialRetryIntervalMillis === undefined &&
                            options?.maxRetryAttempts === undefined &&
                            options?.maxRetryDurationMillis === undefined &&
                            options?.maxRetryIntervalMillis === undefined) {
                            // If no retry option was set, simply throw the error.
                            // This will lead to the invoker applying its retry, without the SDK overriding it.
                            throw err;
                        }
                        handle = this.coreVm.sys_run_exit_failure_transient(err.message, err.cause?.toString(), BigInt(attemptDuration), {
                            factor: options?.retryIntervalFactor || 2.0,
                            initial_interval: options?.initialRetryIntervalMillis || 50,
                            max_attempts: options?.maxRetryAttempts,
                            max_duration: options?.maxRetryDurationMillis,
                            max_interval: options?.maxRetryIntervalMillis || 10 * 1000,
                        });
                    }
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-expect-error
                    handle = this.coreVm.sys_run_exit_success(serde.serialize(res));
                }
            }
            catch (e) {
                this.handleInvocationEndError(e);
                return pendingPromise();
            }
            // Got the handle, wait for the result now (which we get once we get the ack)
            return await this.pollAsyncResult(handle, (asyncResultValue) => {
                if (typeof asyncResultValue === "object" &&
                    "Success" in asyncResultValue) {
                    return serde.deserialize(asyncResultValue.Success);
                }
                else if (typeof asyncResultValue === "object" &&
                    "Failure" in asyncResultValue) {
                    throw new errors_js_1.TerminalError(asyncResultValue.Failure.message, {
                        errorCode: asyncResultValue.Failure.code,
                    });
                }
                throw new Error(`Unexpected variant in async result: ${JSON.stringify(asyncResultValue)}`);
            });
        };
        return doRun();
    }
    sleep(millis) {
        return this.processCompletableEntry((vm) => vm.sys_sleep(BigInt(millis)), (asyncResultValue) => {
            if (asyncResultValue === "Empty") {
                // Empty
                return undefined;
            }
            else if ("Failure" in asyncResultValue) {
                throw new errors_js_1.TerminalError(asyncResultValue.Failure.message, {
                    errorCode: asyncResultValue.Failure.code,
                });
            }
            throw new Error(`Unexpected variant in async result: ${JSON.stringify(asyncResultValue)}`);
        });
    }
    // -- Awakeables
    awakeable(serde) {
        let awakeable;
        try {
            awakeable = this.coreVm.sys_awakeable();
        }
        catch (e) {
            this.handleInvocationEndError(e);
            return {
                id: "invalid",
                promise: new LazyContextPromise(0, this, () => pendingPromise()),
            };
        }
        return {
            id: awakeable.id,
            promise: new LazyContextPromise(awakeable.handle, this, () => this.pollAsyncResult(awakeable.handle, (asyncResultValue) => {
                if (typeof asyncResultValue === "object" &&
                    "Success" in asyncResultValue) {
                    if (!serde) {
                        return (0, rpc_js_1.defaultSerde)().deserialize(asyncResultValue.Success);
                    }
                    if (asyncResultValue.Success.length === 0) {
                        return undefined;
                    }
                    return serde.deserialize(asyncResultValue.Success);
                }
                else if (typeof asyncResultValue === "object" &&
                    "Failure" in asyncResultValue) {
                    throw new errors_js_1.TerminalError(asyncResultValue.Failure.message, {
                        errorCode: asyncResultValue.Failure.code,
                    });
                }
                throw new Error(`Unexpected variant in async result: ${JSON.stringify(asyncResultValue)}`);
            })),
        };
    }
    resolveAwakeable(id, payload, serde) {
        this.processNonCompletableEntry((vm) => {
            // We coerce undefined to null as null can be stringified by JSON.stringify
            let value;
            if (serde) {
                value =
                    payload === undefined ? new Uint8Array() : serde.serialize(payload);
            }
            else {
                value =
                    payload !== undefined
                        ? (0, rpc_js_1.defaultSerde)().serialize(payload)
                        : (0, rpc_js_1.defaultSerde)().serialize(null);
            }
            vm.sys_complete_awakeable_success(id, value);
        });
    }
    rejectAwakeable(id, reason) {
        this.processNonCompletableEntry((vm) => {
            vm.sys_complete_awakeable_failure(id, {
                code: errors_js_1.UNKNOWN_ERROR_CODE,
                message: reason,
            });
        });
    }
    promise(name, serde) {
        return new DurablePromiseImpl(this, name, serde);
    }
    // Used by static methods of CombineablePromise
    static createCombinator(combinatorType, promises) {
        // Extract context from first promise
        const self = extractContext(promises[0]);
        if (!self) {
            throw new Error("Not a combinable promise");
        }
        // Collect first the promises downcasted to the internal promise type
        const castedPromises = [];
        for (const promise of promises) {
            if (extractContext(promise) !== self) {
                self.handleInvocationEndError(new Error("You're mixing up CombineablePromises from different RestateContext. This is not supported."));
                return pendingPromise();
            }
            castedPromises.push(promise);
        }
        const handles = new Uint32Array(castedPromises.map((p) => p.asyncResultHandle));
        // From now on, lazily executes on await
        return new LazyPromise(async () => {
            let combinatorResultHandle;
            try {
                // Take output
                const nextOutput1 = self.coreVm.take_output();
                if (nextOutput1 instanceof Uint8Array) {
                    await self.outputWriter.write(nextOutput1);
                }
                for (;;) {
                    switch (combinatorType) {
                        case "All":
                            combinatorResultHandle =
                                self.coreVm.sys_try_complete_all_combinator(handles);
                            break;
                        case "Any":
                            combinatorResultHandle =
                                self.coreVm.sys_try_complete_any_combinator(handles);
                            break;
                        case "AllSettled":
                            combinatorResultHandle =
                                self.coreVm.sys_try_complete_all_settled_combinator(handles);
                            break;
                        case "Race":
                        case "OrTimeout":
                            combinatorResultHandle =
                                self.coreVm.sys_try_complete_race_combinator(handles);
                            break;
                    }
                    // We got a result, we're done in this loop
                    if (combinatorResultHandle !== undefined) {
                        break;
                    }
                    // No result yet, await the next read
                    await self.awaitNextRead();
                }
                // We got a result, we need to take_output to write the combinator entry, then we need to poll the result
                const nextOutput = self.coreVm.take_output();
                if (nextOutput instanceof Uint8Array) {
                    await self.outputWriter.write(nextOutput);
                }
            }
            catch (e) {
                if (e instanceof errors_js_1.TerminalError) {
                    // All good, this is a recorded failure
                    throw e;
                }
                // Not good, this is a retryable error.
                self.handleInvocationEndError(e);
                return await pendingPromise();
            }
            const handlesResult = await self.pollAsyncResult(combinatorResultHandle, (asyncResultValue) => {
                if (typeof asyncResultValue === "object" &&
                    "CombinatorResult" in asyncResultValue) {
                    return asyncResultValue.CombinatorResult;
                }
                throw new Error(`Unexpected variant in async result: ${JSON.stringify(asyncResultValue)}`);
            });
            const promisesMap = new Map(castedPromises.map((p) => [p.asyncResultHandle, p]));
            // Now all we need to do is to construct the final output based on the handles,
            // this depends on combinators themselves.
            switch (combinatorType) {
                case "All":
                    return this.extractAllCombinatorResult(handlesResult, promisesMap);
                case "Any":
                    return this.extractAnyCombinatorResult(handlesResult, promisesMap);
                case "AllSettled":
                    return this.extractAllSettledCombinatorResult(handlesResult, promisesMap);
                case "Race":
                    // Just one promise succeeded
                    return promisesMap.get(handlesResult[0]);
                case "OrTimeout":
                    // The sleep promise is always the second one in the list.
                    if (handlesResult[0] === castedPromises[1].asyncResultHandle) {
                        return Promise.reject(new errors_js_1.TimeoutError());
                    }
                    else {
                        return promisesMap.get(handlesResult[0]);
                    }
            }
        });
    }
    static async extractAllCombinatorResult(handlesResult, promisesMap) {
        // The result can either all values, or one error
        const resultValues = [];
        for (const handle of handlesResult) {
            try {
                resultValues.push(await promisesMap.get(handle));
            }
            catch (e) {
                return Promise.reject(e);
            }
        }
        return Promise.resolve(resultValues);
    }
    static async extractAnyCombinatorResult(handlesResult, promisesMap) {
        // The result can either be one value, or a list of errors
        const resultFailures = [];
        for (const handle of handlesResult) {
            try {
                return Promise.resolve(await promisesMap.get(handle));
            }
            catch (e) {
                resultFailures.push(e);
            }
        }
        // Giving back the cause here is completely fine, because all these errors in Aggregate error are Terminal errors!
        return Promise.reject(new errors_js_1.TerminalError("All input promises failed", {
            cause: new AggregateError(resultFailures),
        }));
    }
    static async extractAllSettledCombinatorResult(handlesResult, promisesMap) {
        const resultValues = [];
        for (const handle of handlesResult) {
            try {
                resultValues.push(await promisesMap.get(handle));
            }
            catch (e) {
                resultValues.push(e);
            }
        }
        return Promise.resolve(resultValues);
    }
    // -- Various private methods
    processNonCompletableEntry(vmCall) {
        try {
            vmCall(this.coreVm);
        }
        catch (e) {
            this.handleInvocationEndError(e);
        }
    }
    processCompletableEntry(vmCall, transformer) {
        let handle;
        try {
            handle = vmCall(this.coreVm);
        }
        catch (e) {
            this.handleInvocationEndError(e);
            return new LazyContextPromise(0, this, () => pendingPromise());
        }
        return new LazyContextPromise(handle, this, () => this.pollAsyncResult(handle, transformer));
    }
    async pollAsyncResult(handle, transformer) {
        try {
            // Take output
            const nextOutput = this.coreVm.take_output();
            if (nextOutput instanceof Uint8Array) {
                await this.outputWriter.write(nextOutput);
            }
            // Now loop waiting for the async result
            let asyncResult = this.coreVm.take_async_result(handle);
            while (asyncResult === "NotReady") {
                await this.awaitNextRead();
                // Using notify_await_point immediately before take_async_result
                // makes sure the state machine will try to suspend only now,
                // in case there aren't other concurrent tasks trying to poll this async result.
                this.coreVm.notify_await_point(handle);
                asyncResult = this.coreVm.take_async_result(handle);
            }
            return transformer(asyncResult);
        }
        catch (e) {
            if (e instanceof errors_js_1.TerminalError) {
                // All good, this is a recorded failure
                throw e;
            }
            // Not good, this is a retryable error.
            this.handleInvocationEndError(e);
            return await pendingPromise();
        }
    }
    // This function triggers a read on the input reader,
    // and will notify the caller that a read was executed
    // and the result was piped in the state machine.
    awaitNextRead() {
        if (this.currentRead === undefined) {
            // Register a new read
            this.currentRead = this.readNext().finally(() => {
                this.currentRead = undefined;
            });
        }
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        return new Promise((resolve) => this.currentRead?.finally(resolve));
    }
    async readNext() {
        // Take input, and notify it to the vm
        let nextValue;
        try {
            nextValue = await this.inputReader.read();
        }
        catch (e) {
            this.handleInvocationEndError(e);
            return pendingPromise();
        }
        if (nextValue.value !== undefined) {
            this.coreVm.notify_input(nextValue.value);
        }
        if (nextValue.done) {
            this.coreVm.notify_input_closed();
        }
    }
    handleInvocationEndError(e) {
        const error = (0, errors_js_1.ensureError)(e);
        if (!(error instanceof errors_js_1.RestateError) ||
            error.code !== errors_js_1.SUSPENDED_ERROR_CODE) {
            this.console.warn("Function completed with an error.\n", error);
        }
        this.coreVm.notify_error(error.message, error.stack);
        // From now on, no progress will be made.
        this.invocationEndPromise.resolve();
    }
}
exports.ContextImpl = ContextImpl;
function unpack(a, b) {
    if (typeof a === "string") {
        if (typeof b !== "function") {
            throw new TypeError("");
        }
        return { name: a, action: b };
    }
    if (typeof a !== "function") {
        throw new TypeError("unexpected type at the first parameter");
    }
    if (b) {
        throw new TypeError("unexpected a function as a second parameter.");
    }
    return { action: a };
}
const RESTATE_CTX_SYMBOL = Symbol("restateContext");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function extractContext(n) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return n[RESTATE_CTX_SYMBOL];
}
class DurablePromiseImpl {
    ctx;
    name;
    serde;
    constructor(ctx, name, serde) {
        this.ctx = ctx;
        this.name = name;
        this.serde = serde ?? (0, rpc_js_1.defaultSerde)();
    }
    then(onfulfilled, onrejected) {
        return this.get().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
        return this.get().catch(onrejected);
    }
    finally(onfinally) {
        return this.get().finally(onfinally);
    }
    [Symbol.toStringTag] = "DurablePromise";
    get() {
        return this.ctx.processCompletableEntry((vm) => vm.sys_get_promise(this.name), (asyncResultValue) => {
            if (typeof asyncResultValue === "object" &&
                "Success" in asyncResultValue) {
                return this.serde.deserialize(asyncResultValue.Success);
            }
            else if (typeof asyncResultValue === "object" &&
                "Failure" in asyncResultValue) {
                throw new errors_js_1.TerminalError(asyncResultValue.Failure.message, {
                    errorCode: asyncResultValue.Failure.code,
                });
            }
            throw new Error(`Unexpected variant in async result: ${JSON.stringify(asyncResultValue)}`);
        });
    }
    peek() {
        return this.ctx.processCompletableEntry((vm) => vm.sys_peek_promise(this.name), (asyncResultValue) => {
            if (asyncResultValue === "Empty") {
                return undefined;
            }
            else if (typeof asyncResultValue === "object" &&
                "Success" in asyncResultValue) {
                return this.serde.deserialize(asyncResultValue.Success);
            }
            else if (typeof asyncResultValue === "object" &&
                "Failure" in asyncResultValue) {
                throw new errors_js_1.TerminalError(asyncResultValue.Failure.message, {
                    errorCode: asyncResultValue.Failure.code,
                });
            }
            throw new Error(`Unexpected variant in async result: ${JSON.stringify(asyncResultValue)}`);
        });
    }
    resolve(value) {
        return this.ctx.processCompletableEntry((vm) => vm.sys_complete_promise_success(this.name, this.serde.serialize(value)), (asyncResultValue) => {
            if (asyncResultValue === "Empty") {
                return undefined;
            }
            else if (typeof asyncResultValue === "object" &&
                "Failure" in asyncResultValue) {
                throw new errors_js_1.TerminalError(asyncResultValue.Failure.message, {
                    errorCode: asyncResultValue.Failure.code,
                });
            }
            throw new Error(`Unexpected variant in async result: ${JSON.stringify(asyncResultValue)}`);
        });
    }
    reject(errorMsg) {
        return this.ctx.processCompletableEntry((vm) => vm.sys_complete_promise_failure(this.name, {
            code: errors_js_1.INTERNAL_ERROR_CODE,
            message: errorMsg,
        }), (asyncResultValue) => {
            if (asyncResultValue === "Empty") {
                return undefined;
            }
            else if (typeof asyncResultValue === "object" &&
                "Failure" in asyncResultValue) {
                throw new errors_js_1.TerminalError(asyncResultValue.Failure.message, {
                    errorCode: asyncResultValue.Failure.code,
                });
            }
            throw new Error(`Unexpected variant in async result: ${JSON.stringify(asyncResultValue)}`);
        });
    }
}
class LazyPromise {
    executor;
    _promise;
    constructor(executor) {
        this.executor = executor;
    }
    then(onfulfilled, onrejected) {
        this._promise = this._promise || this.executor();
        return this._promise.then(onfulfilled, onrejected);
    }
    catch(onrejected) {
        this._promise = this._promise || this.executor();
        return this._promise.catch(onrejected);
    }
    finally(onfinally) {
        this._promise = this._promise || this.executor();
        return this._promise.finally(onfinally);
    }
    [Symbol.toStringTag] = "LazyPromise";
}
class LazyContextPromise extends LazyPromise {
    asyncResultHandle;
    [RESTATE_CTX_SYMBOL];
    constructor(asyncResultHandle, ctx, executor) {
        super(executor);
        this.asyncResultHandle = asyncResultHandle;
        this[RESTATE_CTX_SYMBOL] = ctx;
    }
    orTimeout(millis) {
        return ContextImpl.createCombinator("OrTimeout", [
            this,
            this[RESTATE_CTX_SYMBOL].sleep(millis),
        ]);
    }
}
// A promise that is never completed
function pendingPromise() {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    return new Promise(() => { });
}
//# sourceMappingURL=context_impl.js.map