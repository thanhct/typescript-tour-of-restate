"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EndpointBuilder = void 0;
const rpc_js_1 = require("../types/rpc.js");
const components_js_1 = require("../types/components.js");
const logger_js_1 = require("../logger.js");
function isServiceDefinition(m) {
    return m && m.service !== undefined;
}
function isObjectDefinition(m) {
    return m && m.object !== undefined;
}
function isWorkflowDefinition(m) {
    return m && m.workflow !== undefined;
}
class EndpointBuilder {
    services = new Map();
    logger = logger_js_1.defaultLogger;
    /**
     * This is a simple console without contextual info.
     *
     * This should be used only in cases where no contextual info is available.
     */
    rlog = (0, logger_js_1.createRestateConsole)(this.logger, logger_js_1.LogSource.SYSTEM);
    _keySet = [];
    get keySet() {
        return this._keySet;
    }
    componentByName(componentName) {
        return this.services.get(componentName);
    }
    addComponent(component) {
        this.services.set(component.name(), component);
    }
    bind(definition) {
        if (isServiceDefinition(definition)) {
            const { name, service } = definition;
            if (!service) {
                throw new TypeError(`no service implementation found.`);
            }
            this.bindServiceComponent(name, service);
        }
        else if (isObjectDefinition(definition)) {
            const { name, object } = definition;
            if (!object) {
                throw new TypeError(`no object implementation found.`);
            }
            this.bindVirtualObjectComponent(name, object);
        }
        else if (isWorkflowDefinition(definition)) {
            const { name, workflow } = definition;
            if (!workflow) {
                throw new TypeError(`no workflow implementation found.`);
            }
            this.bindWorkflowObjectComponent(name, workflow);
        }
        else {
            throw new TypeError("can only bind a service or a virtual object or a workflow definition");
        }
        return this;
    }
    withIdentityV1(...keys) {
        this._keySet.push(...keys);
        return this;
    }
    setLogger(newLogger) {
        this.logger = newLogger;
        this.rlog = (0, logger_js_1.createRestateConsole)(this.logger, logger_js_1.LogSource.SYSTEM);
        return this;
    }
    computeDiscovery(protocolMode) {
        const services = [...this.services.values()].map((c) => c.discovery());
        const endpoint = {
            protocolMode,
            minProtocolVersion: 2,
            maxProtocolVersion: 2,
            services,
        };
        return endpoint;
    }
    bindServiceComponent(name, router) {
        if (name.indexOf("/") !== -1) {
            throw new Error("service name must not contain any slash '/'");
        }
        const component = new components_js_1.ServiceComponent(name);
        for (const [route, handler] of Object.entries(router)) {
            const wrapper = rpc_js_1.HandlerWrapper.fromHandler(handler);
            if (!wrapper) {
                throw new TypeError(`${route} is not a restate handler.`);
            }
            wrapper.bindInstance(router);
            component.add(route, wrapper);
        }
        this.addComponent(component);
    }
    bindVirtualObjectComponent(name, router) {
        if (name.indexOf("/") !== -1) {
            throw new Error("service name must not contain any slash '/'");
        }
        const component = new components_js_1.VirtualObjectComponent(name);
        for (const [route, handler] of Object.entries(router)) {
            const wrapper = rpc_js_1.HandlerWrapper.fromHandler(handler);
            if (!wrapper) {
                throw new TypeError(`${route} is not a restate handler.`);
            }
            wrapper.bindInstance(router);
            component.add(route, wrapper);
        }
        this.addComponent(component);
    }
    bindWorkflowObjectComponent(name, workflow) {
        if (name.indexOf("/") !== -1) {
            throw new Error("service name must not contain any slash '/'");
        }
        const component = new components_js_1.WorkflowComponent(name);
        for (const [route, handler] of Object.entries(workflow)) {
            const wrapper = rpc_js_1.HandlerWrapper.fromHandler(handler);
            if (!wrapper) {
                throw new TypeError(`${route} is not a restate handler.`);
            }
            wrapper.bindInstance(workflow);
            component.add(route, wrapper);
        }
        this.addComponent(component);
    }
}
exports.EndpointBuilder = EndpointBuilder;
//# sourceMappingURL=endpoint_builder.js.map