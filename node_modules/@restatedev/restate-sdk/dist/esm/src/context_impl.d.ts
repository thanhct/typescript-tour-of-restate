/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import type { CombineablePromise, ContextDate, DurablePromise, GenericCall, GenericSend, ObjectContext, Rand, Request, RunAction, RunOptions, SendOptions, WorkflowContext } from "./context.js";
import type * as vm from "./endpoint/handlers/vm/sdk_shared_core_wasm_bindings.js";
import type { Client, SendClient } from "./types/rpc.js";
import { HandlerKind } from "./types/rpc.js";
import type { Serde, Service, ServiceDefinitionFrom, VirtualObject, VirtualObjectDefinitionFrom, Workflow, WorkflowDefinitionFrom } from "@restatedev/restate-sdk-core";
import type { Headers } from "./endpoint/handlers/generic.js";
import type { ReadableStreamDefaultReader, WritableStreamDefaultWriter } from "node:stream/web";
import type { CompletablePromise } from "./utils/completable_promise.js";
export type InternalCombineablePromise<T> = CombineablePromise<T> & {
    asyncResultHandle: number;
};
export declare class ContextImpl implements ObjectContext, WorkflowContext {
    readonly coreVm: vm.WasmVM;
    readonly input: vm.WasmInput;
    readonly console: Console;
    readonly handlerKind: HandlerKind;
    private readonly invocationEndPromise;
    private readonly inputReader;
    private readonly outputWriter;
    private readonly invocationRequest;
    readonly rand: Rand;
    readonly date: ContextDate;
    private currentRead?;
    constructor(coreVm: vm.WasmVM, input: vm.WasmInput, console: Console, handlerKind: HandlerKind, attemptHeaders: Headers, extraArgs: unknown[], invocationEndPromise: CompletablePromise<void>, inputReader: ReadableStreamDefaultReader<Uint8Array>, outputWriter: WritableStreamDefaultWriter<Uint8Array>);
    get key(): string;
    request(): Request;
    get<T>(name: string, serde?: Serde<T>): Promise<T | null>;
    stateKeys(): Promise<Array<string>>;
    set<T>(name: string, value: T, serde?: Serde<T>): void;
    clear(name: string): void;
    clearAll(): void;
    genericCall<REQ = Uint8Array, RES = Uint8Array>(call: GenericCall<REQ, RES>): CombineablePromise<RES>;
    genericSend<REQ = Uint8Array>(send: GenericSend<REQ>): void;
    serviceClient<D>({ name }: ServiceDefinitionFrom<D>): Client<Service<D>>;
    objectClient<D>({ name }: VirtualObjectDefinitionFrom<D>, key: string): Client<VirtualObject<D>>;
    workflowClient<D>({ name }: WorkflowDefinitionFrom<D>, key: string): Client<Workflow<D>>;
    serviceSendClient<D>({ name }: ServiceDefinitionFrom<D>, opts?: SendOptions): SendClient<Service<D>>;
    objectSendClient<D>({ name }: VirtualObjectDefinitionFrom<D>, key: string, opts?: SendOptions): SendClient<VirtualObject<D>>;
    workflowSendClient<D>({ name }: WorkflowDefinitionFrom<D>, key: string, opts?: SendOptions): SendClient<Workflow<D>>;
    run<T>(nameOrAction: string | RunAction<T>, actionSecondParameter?: RunAction<T>, options?: RunOptions<T>): Promise<T>;
    sleep(millis: number): CombineablePromise<void>;
    awakeable<T>(serde?: Serde<T>): {
        id: string;
        promise: CombineablePromise<T>;
    };
    resolveAwakeable<T>(id: string, payload?: T, serde?: Serde<T>): void;
    rejectAwakeable(id: string, reason: string): void;
    promise<T>(name: string, serde?: Serde<T>): DurablePromise<T>;
    static createCombinator<T extends readonly CombineablePromise<unknown>[]>(combinatorType: PromiseCombinatorType, promises: T): Promise<unknown>;
    private static extractAllCombinatorResult;
    private static extractAnyCombinatorResult;
    private static extractAllSettledCombinatorResult;
    processNonCompletableEntry(vmCall: (vm: vm.WasmVM) => void): void;
    processCompletableEntry<T>(vmCall: (vm: vm.WasmVM) => number, transformer: (value: "Empty" | {
        Success: Uint8Array;
    } | {
        Failure: vm.WasmFailure;
    } | {
        StateKeys: string[];
    } | {
        CombinatorResult: number[];
    }) => T): LazyContextPromise<T>;
    pollAsyncResult<T>(handle: number, transformer: (value: "Empty" | {
        Success: Uint8Array;
    } | {
        Failure: vm.WasmFailure;
    } | {
        StateKeys: string[];
    } | {
        CombinatorResult: number[];
    }) => T): Promise<T>;
    private awaitNextRead;
    private readNext;
    handleInvocationEndError(e: unknown): void;
}
declare const RESTATE_CTX_SYMBOL: unique symbol;
declare class LazyPromise<T> implements Promise<T> {
    private readonly executor;
    private _promise?;
    constructor(executor: () => Promise<T>);
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined): Promise<T | TResult>;
    finally(onfinally?: (() => void) | null | undefined): Promise<T>;
    readonly [Symbol.toStringTag] = "LazyPromise";
}
declare class LazyContextPromise<T> extends LazyPromise<T> implements InternalCombineablePromise<T> {
    readonly asyncResultHandle: number;
    [RESTATE_CTX_SYMBOL]: ContextImpl;
    constructor(asyncResultHandle: number, ctx: ContextImpl, executor: () => Promise<T>);
    orTimeout(millis: number): Promise<T>;
}
type PromiseCombinatorType = "All" | "Any" | "AllSettled" | "Race" | "OrTimeout";
export {};
//# sourceMappingURL=context_impl.d.ts.map