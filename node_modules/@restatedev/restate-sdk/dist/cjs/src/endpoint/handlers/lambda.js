"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LambdaHandler = void 0;
const node_buffer_1 = require("node:buffer");
const web_1 = require("node:stream/web");
const streams_js_1 = require("../../utils/streams.js");
const user_agent_js_1 = require("../../user_agent.js");
const errors_js_1 = require("../../types/errors.js");
class LambdaHandler {
    handler;
    constructor(handler) {
        this.handler = handler;
    }
    async handleRequest(event, context) {
        //
        // Request path
        //
        const path = "path" in event ? event.path : event.rawPath;
        //
        // Convert the request body to a Uint8Array stream
        // Lambda functions receive the body as base64 encoded string
        //
        let body;
        if (!event.body) {
            body = null;
        }
        else if (event.isBase64Encoded) {
            body = (0, streams_js_1.OnceStream)(node_buffer_1.Buffer.from(event.body, "base64"));
        }
        else {
            body = (0, streams_js_1.OnceStream)(new TextEncoder().encode(event.body));
        }
        const request = {
            body,
            headers: event.headers,
            url: path,
            extraArgs: [context],
        };
        const resp = await this.handler.handle(request, {
            AWSRequestId: context.awsRequestId,
        });
        const chunks = [];
        try {
            await resp.body.pipeTo(new web_1.WritableStream({
                write: (chunk) => {
                    chunks.push(chunk);
                },
            }));
        }
        catch (e) {
            // unlike in the streaming case, we can actually catch errors in the response body and form a nicer error
            const error = (0, errors_js_1.ensureError)(e);
            this.handler.endpoint.rlog.error("Error while collecting invocation response: " +
                (error.stack ?? error.message));
            return {
                headers: {
                    "content-type": "application/json",
                    "x-restate-server": user_agent_js_1.X_RESTATE_SERVER,
                },
                statusCode: 500,
                isBase64Encoded: false,
                body: JSON.stringify({ message: error.message }),
            };
        }
        return {
            headers: resp.headers,
            statusCode: resp.statusCode,
            isBase64Encoded: true,
            body: node_buffer_1.Buffer.concat(chunks).toString("base64"),
        };
    }
}
exports.LambdaHandler = LambdaHandler;
//# sourceMappingURL=lambda.js.map