"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseUrlComponents = exports.WorkflowHandler = exports.WorkflowComponent = exports.VirtualObjectHandler = exports.VirtualObjectComponent = exports.ServiceHandler = exports.ServiceComponent = void 0;
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
const d = __importStar(require("./discovery.js"));
const rpc_js_1 = require("./rpc.js");
//
// Service
//
class ServiceComponent {
    componentName;
    handlers = new Map();
    constructor(componentName) {
        this.componentName = componentName;
    }
    name() {
        return this.componentName;
    }
    add(name, handlerWrapper) {
        const serviceHandler = new ServiceHandler(name, handlerWrapper, this);
        this.handlers.set(name, serviceHandler);
    }
    discovery() {
        const handlers = [...this.handlers.entries()].map(([name, serviceHandler]) => {
            return {
                name,
                input: {
                    required: false,
                    contentType: serviceHandler.handlerWrapper.accept ?? "application/json",
                },
                output: {
                    setContentTypeIfEmpty: false,
                    contentType: serviceHandler.handlerWrapper.contentType ?? "application/json",
                },
            };
        });
        return {
            name: this.componentName,
            ty: d.ServiceType.SERVICE,
            handlers,
        };
    }
    handlerMatching(url) {
        return this.handlers.get(url.handlerName);
    }
}
exports.ServiceComponent = ServiceComponent;
class ServiceHandler {
    handlerName;
    parent;
    handlerWrapper;
    constructor(name, handlerWrapper, parent) {
        this.handlerName = name;
        this.parent = parent;
        this.handlerWrapper = handlerWrapper;
    }
    kind() {
        return this.handlerWrapper.kind;
    }
    invoke(context, input) {
        return this.handlerWrapper.invoke(context, input);
    }
    name() {
        return this.handlerName;
    }
    component() {
        return this.parent;
    }
}
exports.ServiceHandler = ServiceHandler;
//
// Virtual Object
//
class VirtualObjectComponent {
    componentName;
    handlers = new Map();
    constructor(componentName) {
        this.componentName = componentName;
    }
    name() {
        return this.componentName;
    }
    add(name, wrapper) {
        this.handlers.set(name, wrapper);
    }
    discovery() {
        const handlers = [...this.handlers.entries()].map(([name, opts]) => {
            return {
                name,
                input: {
                    required: false,
                    contentType: opts.accept ?? "application/json",
                },
                output: {
                    setContentTypeIfEmpty: false,
                    contentType: opts.contentType ?? "application/json",
                },
                ty: opts.kind === rpc_js_1.HandlerKind.EXCLUSIVE
                    ? d.ServiceHandlerType.EXCLUSIVE
                    : d.ServiceHandlerType.SHARED,
            };
        });
        return {
            name: this.componentName,
            ty: d.ServiceType.VIRTUAL_OBJECT,
            handlers,
        };
    }
    handlerMatching(url) {
        const wrapper = this.handlers.get(url.handlerName);
        if (!wrapper) {
            return undefined;
        }
        return new VirtualObjectHandler(url.handlerName, this, wrapper);
    }
}
exports.VirtualObjectComponent = VirtualObjectComponent;
class VirtualObjectHandler {
    componentName;
    parent;
    handlerWrapper;
    constructor(componentName, parent, handlerWrapper) {
        this.componentName = componentName;
        this.parent = parent;
        this.handlerWrapper = handlerWrapper;
    }
    name() {
        return this.componentName;
    }
    component() {
        return this.parent;
    }
    kind() {
        return this.handlerWrapper.kind;
    }
    invoke(context, input) {
        return this.handlerWrapper.invoke(context, input);
    }
}
exports.VirtualObjectHandler = VirtualObjectHandler;
// Workflow
class WorkflowComponent {
    componentName;
    handlers = new Map();
    constructor(componentName) {
        this.componentName = componentName;
    }
    name() {
        return this.componentName;
    }
    add(name, wrapper) {
        this.handlers.set(name, wrapper);
    }
    discovery() {
        const handlers = [...this.handlers.entries()].map(([name, handler]) => {
            return {
                name,
                input: {
                    required: false,
                    contentType: handler.accept ?? "application/json",
                },
                output: {
                    setContentTypeIfEmpty: false,
                    contentType: handler.contentType ?? "application/json",
                },
                ty: handler.kind === rpc_js_1.HandlerKind.WORKFLOW
                    ? d.ServiceHandlerType.WORKFLOW
                    : d.ServiceHandlerType.SHARED,
            };
        });
        return {
            name: this.componentName,
            ty: d.ServiceType.WORKFLOW,
            handlers,
        };
    }
    handlerMatching(url) {
        const wrapper = this.handlers.get(url.handlerName);
        if (!wrapper) {
            return undefined;
        }
        return new WorkflowHandler(url.handlerName, this, wrapper);
    }
}
exports.WorkflowComponent = WorkflowComponent;
class WorkflowHandler {
    componentName;
    parent;
    handlerWrapper;
    constructor(componentName, parent, handlerWrapper) {
        this.componentName = componentName;
        this.parent = parent;
        this.handlerWrapper = handlerWrapper;
    }
    name() {
        return this.componentName;
    }
    component() {
        return this.parent;
    }
    kind() {
        return this.handlerWrapper.kind;
    }
    invoke(context, input) {
        return this.handlerWrapper.invoke(context, input);
    }
}
exports.WorkflowHandler = WorkflowHandler;
function parseUrlComponents(urlPath) {
    if (!urlPath) {
        return { type: "unknown", path: "" };
    }
    const fragments = urlPath.split("/");
    if (fragments.length >= 3 && fragments[fragments.length - 3] === "invoke") {
        return {
            type: "invoke",
            componentName: fragments[fragments.length - 2],
            handlerName: fragments[fragments.length - 1],
        };
    }
    if (fragments.length > 0 && fragments[fragments.length - 1] === "discover") {
        return { type: "discover" };
    }
    return { type: "unknown", path: urlPath };
}
exports.parseUrlComponents = parseUrlComponents;
//# sourceMappingURL=components.js.map