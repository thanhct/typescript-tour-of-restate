"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRestateConsole = exports.LogSource = exports.LoggerContext = exports.defaultLogger = exports.DEFAULT_LOGGER_LOG_LEVEL = exports.logLevel = exports.RestateLogLevel = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
var RestateLogLevel;
(function (RestateLogLevel) {
    RestateLogLevel["TRACE"] = "trace";
    RestateLogLevel["DEBUG"] = "debug";
    RestateLogLevel["INFO"] = "info";
    RestateLogLevel["WARN"] = "warn";
    RestateLogLevel["ERROR"] = "error";
})(RestateLogLevel || (exports.RestateLogLevel = RestateLogLevel = {}));
function logLevel(level) {
    switch (level) {
        case RestateLogLevel.TRACE:
            return 1;
        case RestateLogLevel.DEBUG:
            return 2;
        case RestateLogLevel.INFO:
            return 3;
        case RestateLogLevel.WARN:
            return 4;
        case RestateLogLevel.ERROR:
            return 5;
    }
}
exports.logLevel = logLevel;
function logLevelFromName(name) {
    if (!name) {
        return null;
    }
    const n = name.toUpperCase();
    switch (n) {
        case "TRACE":
            return RestateLogLevel.TRACE;
        case "DEBUG":
            return RestateLogLevel.DEBUG;
        case "INFO":
            return RestateLogLevel.INFO;
        case "WARN":
            return RestateLogLevel.WARN;
        case "ERROR":
            return RestateLogLevel.ERROR;
        default:
            throw new TypeError(`unknown name ${name}`);
    }
}
// this is the log level as provided by the environment variable RESTATE_LOG_LEVEL,
// but it only affects the default logger - custom loggers get all log events and
// should use their own filtering mechanism
exports.DEFAULT_LOGGER_LOG_LEVEL = readRestateLogLevel();
const defaultLogger = (params, message, ...optionalParams) => {
    if (params.replaying) {
        return;
    }
    if (logLevel(params.level) < logLevel(exports.DEFAULT_LOGGER_LOG_LEVEL)) {
        return;
    }
    const p = `${formatLogPrefix(params.context)}[${new Date().toISOString()}] ${params.level.toUpperCase()}: `;
    switch (params.level) {
        case RestateLogLevel.TRACE:
            return console.trace(p, message, ...optionalParams);
        case RestateLogLevel.DEBUG:
            return console.debug(p, message, ...optionalParams);
        case RestateLogLevel.INFO:
            return console.info(p, message, ...optionalParams);
        case RestateLogLevel.WARN:
            return console.warn(p, message, ...optionalParams);
        case RestateLogLevel.ERROR:
            return console.error(p, message, ...optionalParams);
        default:
            throw new TypeError(`unset or unknown log level ${params.level}`);
    }
};
exports.defaultLogger = defaultLogger;
function readRestateLogLevel() {
    const env = globalThis.process?.env?.RESTATE_LOGGING;
    const level = logLevelFromName(env);
    if (level !== null) {
        return level;
    }
    return RestateLogLevel.INFO;
}
class LoggerContext {
    invocationId;
    additionalContext;
    fqMethodName;
    constructor(invocationId, packageName, serviceName, handlerName, additionalContext) {
        this.invocationId = invocationId;
        this.additionalContext = additionalContext;
        this.fqMethodName = packageName
            ? `${packageName}.${serviceName}/${handlerName}`
            : `${serviceName}/${handlerName}`;
    }
}
exports.LoggerContext = LoggerContext;
function formatLogPrefix(context) {
    if (context === undefined) {
        return "[restate] ";
    }
    let prefix = `[restate] [${context.fqMethodName}][${context.invocationId}]`;
    if (context.additionalContext !== undefined) {
        for (const [k, v] of Object.entries(context.additionalContext)) {
            prefix = prefix + `[${k}: ${v}]`;
        }
    }
    return prefix;
}
function loggerForLevel(logger, source, level, isReplaying, context) {
    return {
        get: () => {
            return logger.bind(null, {
                source,
                level,
                replaying: isReplaying(),
                context,
            });
        },
    };
}
var LogSource;
(function (LogSource) {
    LogSource["SYSTEM"] = "SYSTEM";
    LogSource["JOURNAL"] = "JOURNAL";
    LogSource["USER"] = "USER";
})(LogSource || (exports.LogSource = LogSource = {}));
function createRestateConsole(logger, source, context, isReplaying = () => false) {
    const info = loggerForLevel(logger, source, RestateLogLevel.INFO, isReplaying, context);
    return Object.create(console, {
        trace: loggerForLevel(logger, source, RestateLogLevel.TRACE, isReplaying, context),
        debug: loggerForLevel(logger, source, RestateLogLevel.DEBUG, isReplaying, context),
        info,
        log: info,
        warn: loggerForLevel(logger, source, RestateLogLevel.WARN, isReplaying, context),
        error: loggerForLevel(logger, source, RestateLogLevel.ERROR, isReplaying, context),
    });
}
exports.createRestateConsole = createRestateConsole;
//# sourceMappingURL=logger.js.map