"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.vm_log = exports.GenericHandler = exports.ServiceDiscoveryProtocolVersion = void 0;
const errors_js_1 = require("../../types/errors.js");
const components_js_1 = require("../../types/components.js");
const user_agent_js_1 = require("../../user_agent.js");
const web_1 = require("node:stream/web");
const streams_js_1 = require("../../utils/streams.js");
const context_impl_js_1 = require("../../context_impl.js");
const logger_js_1 = require("../../logger.js");
const vm = __importStar(require("./vm/sdk_shared_core_wasm_bindings.js"));
const completable_promise_js_1 = require("../../utils/completable_promise.js");
var ServiceDiscoveryProtocolVersion;
(function (ServiceDiscoveryProtocolVersion) {
    /**
     * @generated from enum value: SERVICE_DISCOVERY_PROTOCOL_VERSION_UNSPECIFIED = 0;
     */
    ServiceDiscoveryProtocolVersion[ServiceDiscoveryProtocolVersion["SERVICE_DISCOVERY_PROTOCOL_VERSION_UNSPECIFIED"] = 0] = "SERVICE_DISCOVERY_PROTOCOL_VERSION_UNSPECIFIED";
    /**
     * initial service discovery protocol version using endpoint_manifest_schema.json
     *
     * @generated from enum value: V1 = 1;
     */
    ServiceDiscoveryProtocolVersion[ServiceDiscoveryProtocolVersion["V1"] = 1] = "V1";
})(ServiceDiscoveryProtocolVersion || (exports.ServiceDiscoveryProtocolVersion = ServiceDiscoveryProtocolVersion = {}));
/**
 * This is an internal API to support 'fetch' like handlers.
 * It supports both request-reply mode and bidirectional streaming mode.
 *
 * An individual handler will have to convert the shape of the incoming request
 * to a RestateRequest, and then pass it to this handler, and eventually convert back
 * the response.
 * Different runtimes have slightly different shapes of the incoming request, and responses.
 */
class GenericHandler {
    endpoint;
    protocolMode;
    identityVerifier;
    constructor(endpoint, protocolMode) {
        this.endpoint = endpoint;
        this.protocolMode = protocolMode;
        // Setup identity verifier
        if (this.endpoint.keySet === undefined ||
            this.endpoint.keySet.length === 0) {
            this.endpoint.rlog.warn(`Accepting requests without validating request signatures; handler access must be restricted`);
        }
        else {
            this.endpoint.rlog.info(`Validating requests using signing keys [${this.endpoint.keySet}]`);
            this.identityVerifier = new vm.WasmIdentityVerifier(this.endpoint.keySet);
        }
        // Set the logging level in the shared core too!
        switch (logger_js_1.DEFAULT_LOGGER_LOG_LEVEL) {
            case logger_js_1.RestateLogLevel.TRACE:
                vm.set_log_level(vm.LogLevel.TRACE);
                break;
            case logger_js_1.RestateLogLevel.DEBUG:
                vm.set_log_level(vm.LogLevel.DEBUG);
                break;
            case logger_js_1.RestateLogLevel.INFO:
                vm.set_log_level(vm.LogLevel.INFO);
                break;
            case logger_js_1.RestateLogLevel.WARN:
                vm.set_log_level(vm.LogLevel.WARN);
                break;
            case logger_js_1.RestateLogLevel.ERROR:
                vm.set_log_level(vm.LogLevel.ERROR);
                break;
        }
    }
    // handle does not throw.
    async handle(request, context) {
        try {
            return await this._handle(request, context);
        }
        catch (e) {
            const error = (0, errors_js_1.ensureError)(e);
            this.endpoint.rlog.error("Error while handling invocation: " + (error.stack ?? error.message));
            return this.toErrorResponse(500, error.message);
        }
    }
    async _handle(request, context) {
        // this is the recommended way to get the relative path from a url that may be relative or absolute
        const path = new URL(request.url, "https://example.com").pathname;
        const parsed = (0, components_js_1.parseUrlComponents)(path);
        const error = this.validateConnectionSignature(path, request.headers);
        if (error !== null) {
            return error;
        }
        if (parsed.type === "unknown") {
            const msg = `Invalid path: path doesn't end in /invoke/SvcName/handlerName and also not in /discover: ${path}`;
            this.endpoint.rlog.trace(msg);
            return this.toErrorResponse(404, msg);
        }
        if (parsed.type === "discover") {
            return this.handleDiscovery(request.headers["accept"]);
        }
        const serviceProtocolVersionString = request.headers["content-type"];
        if (typeof serviceProtocolVersionString !== "string") {
            const errorMessage = "Missing content-type header";
            this.endpoint.rlog.warn(errorMessage);
            return this.toErrorResponse(415, errorMessage);
        }
        const method = this.endpoint.componentByName(parsed.componentName);
        if (!method) {
            const msg = `No service found for URL: ${JSON.stringify(parsed)}`;
            this.endpoint.rlog.error(msg);
            return this.toErrorResponse(404, msg);
        }
        const handler = method?.handlerMatching(parsed);
        if (!handler) {
            const msg = `No service found for URL: ${JSON.stringify(parsed)}`;
            this.endpoint.rlog.error(msg);
            return this.toErrorResponse(404, msg);
        }
        if (!request.body) {
            const msg = "The incoming message body was null";
            this.endpoint.rlog.error(msg);
            return this.toErrorResponse(400, msg);
        }
        return this.handleInvoke(handler, request.body, request.headers, request.extraArgs, context ?? {});
    }
    validateConnectionSignature(path, headers) {
        if (!this.identityVerifier) {
            // not validating
            return null;
        }
        const vmHeaders = Object.entries(headers)
            .filter(([, v]) => v !== undefined)
            .map(([k, v]) => new vm.WasmHeader(k, v instanceof Array ? v[0] : v));
        try {
            this.identityVerifier.verify_identity(path, vmHeaders);
            return null;
        }
        catch (e) {
            this.endpoint.rlog.error(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Rejecting request as its JWT did not validate: ${e}`);
            return this.toErrorResponse(401, "Unauthorized");
        }
    }
    async handleInvoke(handler, body, headers, extraArgs, additionalContext) {
        // Instantiate core vm and prepare response headers
        const vmHeaders = Object.entries(headers)
            .filter(([, v]) => v !== undefined)
            .map(([k, v]) => new vm.WasmHeader(k, v instanceof Array ? v[0] : v));
        const coreVm = new vm.WasmVM(vmHeaders);
        const responseHead = coreVm.get_response_head();
        const responseHeaders = responseHead.headers.reduce((headers, { key, value }) => ({
            [key]: value,
            ...headers,
        }), {
            "x-restate-server": user_agent_js_1.X_RESTATE_SERVER,
        });
        const inputReader = body.getReader();
        // Now buffer input entries
        while (!coreVm.is_ready_to_execute()) {
            const nextValue = await inputReader.read();
            if (nextValue.value !== undefined) {
                coreVm.notify_input(nextValue.value);
            }
            if (nextValue.done) {
                coreVm.notify_input_closed();
                break;
            }
        }
        // Get input
        const input = coreVm.sys_input();
        // Prepare context
        const console = (0, logger_js_1.createRestateConsole)(this.endpoint.logger, logger_js_1.LogSource.USER, new logger_js_1.LoggerContext(input.invocation_id, "", handler.component().name(), handler.name(), additionalContext), () => !coreVm.is_processing());
        // This promise is used to signal the end of the computation,
        // which can be either the user returns a value,
        // or an exception gets catched, or the state machine fails/suspends.
        //
        // The last case is handled internally within the ContextImpl.
        const invocationEndPromise = new completable_promise_js_1.CompletablePromise();
        // Prepare response stream
        const responseTransformStream = new web_1.TransformStream();
        const outputWriter = responseTransformStream.writable.getWriter();
        // Prepare context
        const ctx = new context_impl_js_1.ContextImpl(coreVm, input, console, handler.kind(), headers, extraArgs, invocationEndPromise, inputReader, outputWriter);
        // Finally invoke user handler
        handler
            .invoke(ctx, input.input)
            .then((bytes) => {
            coreVm.sys_write_output_success(bytes);
            coreVm.sys_end();
        })
            .catch((e) => {
            const error = (0, errors_js_1.ensureError)(e);
            if (!(error instanceof errors_js_1.RestateError) ||
                error.code !== errors_js_1.SUSPENDED_ERROR_CODE) {
                console.warn("Function completed with an error.\n", error);
            }
            if (error instanceof errors_js_1.TerminalError) {
                coreVm.sys_write_output_failure({
                    code: error.code,
                    message: error.message,
                });
                coreVm.sys_end();
            }
            else {
                coreVm.notify_error(error.message, error.stack);
            }
        })
            .finally(() => {
            invocationEndPromise.resolve();
        });
        // Let's wire up invocationEndPromise with consuming all the output and closing the streams.
        invocationEndPromise.promise
            .then(async () => {
            // Consume output till the end, write it out, then close the stream
            let nextOutput = coreVm.take_output();
            while (nextOutput !== null && nextOutput !== undefined) {
                await outputWriter.write(nextOutput);
                nextOutput = coreVm.take_output();
            }
            await outputWriter.close();
            // Let's cancel the input reader, if it's still here
            inputReader.cancel().catch(() => { });
        })
            .catch(() => { });
        return {
            headers: responseHeaders,
            statusCode: responseHead.status_code,
            body: responseTransformStream.readable,
        };
    }
    handleDiscovery(acceptVersionsString) {
        if (typeof acceptVersionsString !== "string") {
            const errorMessage = "Missing accept header";
            this.endpoint.rlog.warn(errorMessage);
            return this.toErrorResponse(415, errorMessage);
        }
        if (!acceptVersionsString.includes("application/vnd.restate.endpointmanifest.v1+json")) {
            const errorMessage = `Unsupported service discovery protocol version '${acceptVersionsString}'`;
            this.endpoint.rlog.warn(errorMessage);
            return this.toErrorResponse(415, errorMessage);
        }
        const discovery = this.endpoint.computeDiscovery(this.protocolMode);
        const body = JSON.stringify(discovery);
        return {
            headers: {
                "content-type": "application/vnd.restate.endpointmanifest.v1+json",
                "x-restate-server": user_agent_js_1.X_RESTATE_SERVER,
            },
            statusCode: 200,
            body: (0, streams_js_1.OnceStream)(new TextEncoder().encode(body)),
        };
    }
    toErrorResponse(code, message) {
        return {
            headers: {
                "content-type": "application/json",
                "x-restate-server": user_agent_js_1.X_RESTATE_SERVER,
            },
            statusCode: code,
            body: (0, streams_js_1.OnceStream)(new TextEncoder().encode(JSON.stringify({ message }))),
        };
    }
}
exports.GenericHandler = GenericHandler;
function wasmLogLevelToRestateLogLevel(level) {
    switch (level) {
        case vm.LogLevel.TRACE:
            return logger_js_1.RestateLogLevel.TRACE;
        case vm.LogLevel.DEBUG:
            return logger_js_1.RestateLogLevel.DEBUG;
        case vm.LogLevel.INFO:
            return logger_js_1.RestateLogLevel.INFO;
        case vm.LogLevel.WARN:
            return logger_js_1.RestateLogLevel.WARN;
        case vm.LogLevel.ERROR:
            return logger_js_1.RestateLogLevel.ERROR;
    }
}
/// This is used by the shared core!
function vm_log(level, str) {
    (0, logger_js_1.defaultLogger)({
        level: wasmLogLevelToRestateLogLevel(level),
        replaying: false,
        source: logger_js_1.LogSource.JOURNAL,
    }, str);
}
exports.vm_log = vm_log;
//# sourceMappingURL=generic.js.map