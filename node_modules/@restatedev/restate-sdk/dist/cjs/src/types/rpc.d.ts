import type { CombineablePromise, Context, GenericCall, GenericSend, ObjectContext, ObjectSharedContext, WorkflowContext, WorkflowSharedContext } from "../context.js";
import { type ServiceHandler, type ServiceDefinition, type ObjectHandler, type ObjectSharedHandler, type VirtualObjectDefinition, type WorkflowHandler, type WorkflowDefinition, type WorkflowSharedHandler, type Serde } from "@restatedev/restate-sdk-core";
export type ClientCallOptions<I, O> = {
    input?: Serde<I>;
    output?: Serde<O>;
};
export declare class Opts<I, O> {
    private readonly opts;
    /**
     * Create a call configuration from the provided options.
     *
     * @param opts the call configuration
     */
    static from<I, O>(opts: ClientCallOptions<I, O>): Opts<I, O>;
    private constructor();
    getOpts(): ClientCallOptions<I, O>;
}
export type ClientSendOptions<I> = {
    input?: Serde<I>;
    delay?: number;
};
export declare class SendOpts<I> {
    private readonly opts;
    static from<I>(opts: ClientSendOptions<I>): SendOpts<I>;
    getOpts(): ClientSendOptions<I>;
    private constructor();
}
export declare namespace rpc {
    const opts: <I, O>(opts: ClientCallOptions<I, O>) => Opts<I, O>;
    const sendOpts: <I>(opts: ClientSendOptions<I>) => SendOpts<I>;
}
export declare const defaultSerde: <T>() => Serde<T>;
export declare const makeRpcCallProxy: <T>(genericCall: (call: GenericCall<unknown, unknown>) => Promise<unknown>, service: string, key?: string) => T;
export declare const makeRpcSendProxy: <T>(genericSend: (send: GenericSend<unknown>) => void, service: string, key?: string, legacyDelay?: number) => T;
export type InferArg<P> = P extends [infer A, ...any[]] ? A : unknown;
export type Client<M> = {
    [K in keyof M as M[K] extends never ? never : K]: M[K] extends (arg: any, ...args: infer P) => PromiseLike<infer O> ? (...args: [...P, ...[opts?: Opts<InferArg<P>, O>]]) => CombineablePromise<O> : never;
};
export type SendClient<M> = {
    [K in keyof M as M[K] extends never ? never : K]: M[K] extends (arg: any, ...args: infer P) => any ? (...args: [...P, ...[opts?: SendOpts<InferArg<P>>]]) => void : never;
};
export declare enum HandlerKind {
    SERVICE = 0,
    EXCLUSIVE = 1,
    SHARED = 2,
    WORKFLOW = 3
}
export type ServiceHandlerOpts = {
    /**
     * Define the acceptable content-type. Wildcards can be used, e.g. `application/*` or `* / *`.
     * If not provided, the `input.contentType` will be used instead.
     *
     * Setting this value has no effect on the input serde.
     * If you want to customize how to deserialize the input, you still need to provide an `input` serde.
     */
    accept?: string;
    /** @deprecated Use input instead */
    inputDeserializer?: <T>(input: Uint8Array) => T | undefined;
    /** @deprecated Use output instead */
    contentType?: string;
    /** @deprecated Use output instead */
    outputSerializer?: <T>(output: T | undefined) => Uint8Array;
    /**
     * The Serde to use for deserializing the input parameter.
     * defaults to: restate.serde.json
     *
     * Provide a custom Serde if the input is not JSON, or use:
     * restate.serde.binary the skip serialization/deserialization altogether.
     * in that case, the input parameter is a Uint8Array.
     */
    input?: Serde<unknown>;
    /**
     * The Serde to use for serializing the output.
     * defaults to: restate.serde.json
     *
     * Provide a custom Serde if the output is not JSON, or use:
     * restate.serde.binary the skip serialization/deserialization altogether.
     * in that case, the output parameter is a Uint8Array.
     */
    output?: Serde<unknown>;
};
export type ObjectHandlerOpts = {
    /**
     * Define the acceptable content-type. Wildcards can be used, e.g. `application/*` or `* / *`.
     * If not provided, the `input.contentType` will be used instead.
     *
     * Setting this value has no effect on the input serde.
     * If you want to customize how to deserialize the input, you still need to provide an `input` serde.
     */
    accept?: string;
    /** @deprecated Use input instead */
    inputDeserializer?: <T>(input: Uint8Array) => T | undefined;
    /** @deprecated Use output instead */
    contentType?: string;
    /** @deprecated Use output instead */
    outputSerializer?: <T>(output: T | undefined) => Uint8Array;
    /**
     * The Serde to use for deserializing the input parameter.
     * defaults to: restate.serde.json
     *
     * Provide a custom Serde if the input is not JSON, or use:
     * restate.serde.binary the skip serialization/deserialization altogether.
     * in that case, the input parameter is a Uint8Array.
     */
    input?: Serde<unknown>;
    /**
     * The Serde to use for serializing the output.
     * defaults to: restate.serde.json
     *
     * Provide a custom Serde if the output is not JSON, or use:
     * restate.serde.binary the skip serialization/deserialization altogether.
     * in that case, the output parameter is a Uint8Array.
     */
    output?: Serde<unknown>;
};
export type WorkflowHandlerOpts = {
    /**
     * Define the acceptable content-type. Wildcards can be used, e.g. `application/*` or `* / *`.
     * If not provided, the `input.contentType` will be used instead.
     *
     * Setting this value has no effect on the input serde.
     * If you want to customize how to deserialize the input, you still need to provide an `input` serde.
     */
    accept?: string;
    /** @deprecated Use input instead */
    inputDeserializer?: <T>(input: Uint8Array) => T | undefined;
    /** @deprecated Use output instead */
    contentType?: string;
    /** @deprecated Use output instead */
    outputSerializer?: <T>(output: T | undefined) => Uint8Array;
    /**
     * The Serde to use for deserializing the input parameter.
     * defaults to: restate.serde.json
     *
     * Provide a custom Serde if the input is not JSON, or use:
     * restate.serde.binary the skip serialization/deserialization altogether.
     * in that case, the input parameter is a Uint8Array.
     */
    input?: Serde<unknown>;
    /**
     * The Serde to use for serializing the output.
     * defaults to: restate.serde.json
     *
     * Provide a custom Serde if the output is not JSON, or use:
     * restate.serde.binary the skip serialization/deserialization altogether.
     * in that case, the output parameter is a Uint8Array.
     */
    output?: Serde<unknown>;
};
export declare class HandlerWrapper {
    readonly kind: HandlerKind;
    private handler;
    readonly inputSerde: Serde<unknown>;
    readonly outputSerde: Serde<unknown>;
    static from(kind: HandlerKind, handler: Function, opts?: ServiceHandlerOpts | ObjectHandlerOpts | WorkflowHandlerOpts): HandlerWrapper;
    static fromHandler(handler: any): HandlerWrapper | undefined;
    readonly accept: string;
    readonly contentType: string;
    private constructor();
    bindInstance(t: unknown): void;
    invoke(context: unknown, input: Uint8Array): Promise<Uint8Array>;
    /**
     * Instead of a HandlerWrapper with a handler property,
     * return the original handler with a HandlerWrapper property.
     * This is needed to keep the appearance of regular functions
     * bound to an object, so that for example, `this.foo(ctx, arg)` would
     * work.
     */
    transpose<F>(): F;
}
export declare namespace handlers {
    /**
     * Create a service handler.
     *
     * @param opts additional configuration
     * @param fn the actual handler code to execute
     */
    function handler<F>(opts: ServiceHandlerOpts, fn: ServiceHandler<F, Context>): F;
    namespace workflow {
        function workflow<F>(opts: WorkflowHandlerOpts, fn: WorkflowHandler<F, WorkflowContext<any>>): F;
        function workflow<F>(fn: WorkflowHandler<F, WorkflowContext<any>>): F;
        /**
         * Creates a shared handler for a workflow.
         *
         * A shared handler allows a read-only concurrent execution
         * for a given key.
         *
         * @param opts additional configurations
         * @param fn the handler to execute
         */
        function shared<F>(opts: WorkflowHandlerOpts, fn: WorkflowSharedHandler<F, WorkflowSharedContext<any>>): F;
        /**
         * Creates a shared handler for a workflow.
         *
         * A shared handler allows a read-only concurrent execution
         * for a given key.
         *
         * @param opts additional configurations
         * @param fn the handler to execute
         */
        function shared<F>(fn: WorkflowSharedHandler<F, WorkflowSharedContext<any>>): F;
    }
    namespace object {
        /**
         * Creates an exclusive handler for a virtual Object.
         *
         * note : This applies only to a virtual object.
         *
         * @param opts additional configurations
         * @param fn the handler to execute
         */
        function exclusive<F>(opts: ObjectHandlerOpts, fn: ObjectHandler<F, ObjectContext<any>>): F;
        /**
         * Creates an exclusive handler for a virtual Object.
         *
         *
         * note 1: This applies only to a virtual object.
         * note 2: This is the default for virtual objects, so if no
         *         additional reconfiguration is needed, you can simply
         *         use the handler directly (no need to use exclusive).
         *         This variant here is only for symmetry/convenance.
         *
         * @param fn the handler to execute
         */
        function exclusive<F>(fn: ObjectHandler<F, ObjectContext<any>>): F;
        /**
         * Creates a shared handler for a virtual Object.
         *
         * A shared handler allows a read-only concurrent execution
         * for a given key.
         *
         * note: This applies only to a virtual object.
         *
         * @param opts additional configurations
         * @param fn the handler to execute
         */
        function shared<F>(opts: ObjectHandlerOpts, fn: ObjectSharedHandler<F, ObjectSharedContext<any>>): F;
        /**
         * Creates a shared handler for a virtual Object.
         *
         * A shared handler allows a read-only concurrent execution
         * for a given key.
         *
         * note: This applies only to a virtual object.
         *
         * @param opts additional configurations
         * @param fn the handler to execute
         */
        function shared<F>(fn: ObjectSharedHandler<F, ObjectSharedContext<any>>): F;
    }
}
export type ServiceOpts<U> = {
    [K in keyof U]: U[K] extends ServiceHandler<any, Context> ? U[K] : never;
};
/**
 * Define a Restate service.
 *
 * @example Here is an example of how to define a service:
 *
 * ```ts
 *  const greeter = service({
 *    name: "greeter",
 *      handlers: {
 *        greet: async (ctx: Context, name: string) => {
 *          return `Hello ${name}`;
 *        }
 *      }
 * });
 * ```
 *
 * To use the service, you can bind it to an endpoint:
 * ```
 * ...
 * endpoint.bind(greeter)
 * ```
 * @example To use a service, you can export its type to be used in a client:
 * ```
 * export type Greeter = typeof greeter;
 * ...
 * ...
 * import type { Greeter } from "./greeter";
 * const client = ctx.serviceClient<Greeter>({ name : "greeter"});
 * client.greet("World").then(console.log);
 * ```
 *
 * @example Alternatively to avoid repeating the service name, you can:
 * ```
 *  import type {Greeter} from "./greeter";
 *  const Greeter: Greeter = { name : "greeter"};
 *
 *  // now you can reference the service like this:
 *  const client = ctx.serviceClient(Greeter);
 * ```
 *
 * @param name the service name
 * @param handlers the handlers for the service
 * @type P the name of the service
 * @type M the handlers for the service
 */
export declare const service: <P extends string, M>(service: {
    name: P;
    handlers: ServiceOpts<M>;
}) => ServiceDefinition<P, M>;
export type ObjectOpts<U> = {
    [K in keyof U]: U[K] extends ObjectHandler<U[K], ObjectContext<any>> ? U[K] : U[K] extends ObjectHandler<U[K], ObjectSharedContext<any>> ? U[K] : never;
};
/**
 * Define a Restate virtual object.
 *
 * @example Here is an example of how to define a virtual object:
 * ```ts
 *        const counter = object({
 *            name: "counter",
 *            handlers: {
 *                  add: async (ctx: ObjectContext, amount: number) => {},
 *                  get: async (ctx: ObjectContext) => {}
 *            }
 *        })
 *  ```
 *
 * @example To use the object, you can bind it to an endpoint:
 * ```ts
 * ...
 * endpoint.bind(counter)
 * ```
 *
 *  @see to interact with the object, you can use the object client:
 * ```ts
 * ...
 * const client = ctx.objectClient<typeof counter>({ name: "counter"});
 * const res = await client.add(1)
 * ```
 *
 * ### Shared handlers
 *
 * Shared handlers are used to allow concurrent read-only access to the object.
 * This is useful when you want to allow multiple clients to read the object's state at the same time.
 * To define a shared handler, you can use the `shared` decorator as shown below:
 *
 * ```ts
 *      const counter = object({
 *          name: "counter",
 *          handlers: {
 *
 *            add: async (ctx: ObjectContext, amount: number) => { .. },
 *
 *            get: handlers.object.shared(async (ctx: ObjectSharedContext) => {
 *                  return ctx.get<number>("count");
 *            })
 *       }
 *     });
 * ```
 *
 * @param name the name of the object
 * @param handlers the handlers for the object
 */
export declare const object: <P extends string, M>(object: {
    name: P;
    handlers: ObjectOpts<M>;
}) => VirtualObjectDefinition<P, M>;
/**
 * A workflow handlers is a type that describes the handlers for a workflow.
 * The handlers must contain exactly one handler named 'run', and this handler must accept as a first argument a WorkflowContext.
 * It can contain any number of additional handlers, which must accept as a first argument a WorkflowSharedContext.
 * The handlers can not be named 'workflowSubmit', 'workflowAttach', 'workflowOutput' - as these are reserved.
 * @see {@link workflow} for an example.
 */
export type WorkflowOpts<U> = {
    run: (ctx: WorkflowContext<any>, argument: any) => Promise<any>;
} & {
    [K in keyof U]: K extends "workflowSubmit" | "workflowAttach" | "workflowOutput" ? `${K} is a reserved keyword` : K extends "run" ? U[K] extends WorkflowHandler<U[K], WorkflowContext<any>> ? U[K] : "An handler named 'run' must take as a first argument a WorkflowContext, and must return a Promise" : U[K] extends WorkflowSharedHandler<U[K], WorkflowSharedContext<any>> ? U[K] : "An handler other then 'run' must accept as a first argument a WorkflowSharedContext";
};
/**
 * Define a Restate workflow.
 *
 *
 * @example Here is an example of how to define a workflow:
 * ```ts
 *      const mywf = workflow({
 *            name: "mywf",
 *            handlers: {
 *                run: async (ctx: WorkflowContext, argument: any) => {
 *                  return "Hello World";
 *                }
 *            }
 *      });
 * ```
 *
 * ### Note:
 * * That a workflow must contain exactly one handler named 'run', and this handler must accept as a first argument a WorkflowContext.
 * * The workflow handlers other than 'run' must accept as a first argument a WorkflowSharedContext.
 * * The workflow handlers can not be named 'workflowSubmit', 'workflowAttach', 'workflowOutput' - as these are reserved keywords.
 *
 * @example To use the workflow, you can bind it to an endpoint:
 * ```ts
 * endpoint.bind(mywf)
 * ```
 *
 * @example To interact with the workflow, you can use the workflow client:
 * ```ts
 * const client = ctx.workflowClient<typeof mywf>({ name: "mywf"});
 * const res = await client.run("Hello");
 * ```
 *
 * To use the workflow client from any other environment (like a browser), please refer to the documentation.
 * https://docs.restate.dev
 *
 *
 *
 * @param name the workflow name
 * @param handlers the handlers for the workflow.
 */
export declare const workflow: <P extends string, M>(workflow: {
    name: P;
    handlers: WorkflowOpts<M>;
}) => WorkflowDefinition<P, M>;
//# sourceMappingURL=rpc.d.ts.map