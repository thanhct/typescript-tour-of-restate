/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
import * as d from "./discovery.js";
import { HandlerKind } from "./rpc.js";
//
// Service
//
export class ServiceComponent {
    componentName;
    handlers = new Map();
    constructor(componentName) {
        this.componentName = componentName;
    }
    name() {
        return this.componentName;
    }
    add(name, handlerWrapper) {
        const serviceHandler = new ServiceHandler(name, handlerWrapper, this);
        this.handlers.set(name, serviceHandler);
    }
    discovery() {
        const handlers = [...this.handlers.entries()].map(([name, serviceHandler]) => {
            return {
                name,
                input: {
                    required: false,
                    contentType: serviceHandler.handlerWrapper.accept ?? "application/json",
                },
                output: {
                    setContentTypeIfEmpty: false,
                    contentType: serviceHandler.handlerWrapper.contentType ?? "application/json",
                },
            };
        });
        return {
            name: this.componentName,
            ty: d.ServiceType.SERVICE,
            handlers,
        };
    }
    handlerMatching(url) {
        return this.handlers.get(url.handlerName);
    }
}
export class ServiceHandler {
    handlerName;
    parent;
    handlerWrapper;
    constructor(name, handlerWrapper, parent) {
        this.handlerName = name;
        this.parent = parent;
        this.handlerWrapper = handlerWrapper;
    }
    kind() {
        return this.handlerWrapper.kind;
    }
    invoke(context, input) {
        return this.handlerWrapper.invoke(context, input);
    }
    name() {
        return this.handlerName;
    }
    component() {
        return this.parent;
    }
}
//
// Virtual Object
//
export class VirtualObjectComponent {
    componentName;
    handlers = new Map();
    constructor(componentName) {
        this.componentName = componentName;
    }
    name() {
        return this.componentName;
    }
    add(name, wrapper) {
        this.handlers.set(name, wrapper);
    }
    discovery() {
        const handlers = [...this.handlers.entries()].map(([name, opts]) => {
            return {
                name,
                input: {
                    required: false,
                    contentType: opts.accept ?? "application/json",
                },
                output: {
                    setContentTypeIfEmpty: false,
                    contentType: opts.contentType ?? "application/json",
                },
                ty: opts.kind === HandlerKind.EXCLUSIVE
                    ? d.ServiceHandlerType.EXCLUSIVE
                    : d.ServiceHandlerType.SHARED,
            };
        });
        return {
            name: this.componentName,
            ty: d.ServiceType.VIRTUAL_OBJECT,
            handlers,
        };
    }
    handlerMatching(url) {
        const wrapper = this.handlers.get(url.handlerName);
        if (!wrapper) {
            return undefined;
        }
        return new VirtualObjectHandler(url.handlerName, this, wrapper);
    }
}
export class VirtualObjectHandler {
    componentName;
    parent;
    handlerWrapper;
    constructor(componentName, parent, handlerWrapper) {
        this.componentName = componentName;
        this.parent = parent;
        this.handlerWrapper = handlerWrapper;
    }
    name() {
        return this.componentName;
    }
    component() {
        return this.parent;
    }
    kind() {
        return this.handlerWrapper.kind;
    }
    invoke(context, input) {
        return this.handlerWrapper.invoke(context, input);
    }
}
// Workflow
export class WorkflowComponent {
    componentName;
    handlers = new Map();
    constructor(componentName) {
        this.componentName = componentName;
    }
    name() {
        return this.componentName;
    }
    add(name, wrapper) {
        this.handlers.set(name, wrapper);
    }
    discovery() {
        const handlers = [...this.handlers.entries()].map(([name, handler]) => {
            return {
                name,
                input: {
                    required: false,
                    contentType: handler.accept ?? "application/json",
                },
                output: {
                    setContentTypeIfEmpty: false,
                    contentType: handler.contentType ?? "application/json",
                },
                ty: handler.kind === HandlerKind.WORKFLOW
                    ? d.ServiceHandlerType.WORKFLOW
                    : d.ServiceHandlerType.SHARED,
            };
        });
        return {
            name: this.componentName,
            ty: d.ServiceType.WORKFLOW,
            handlers,
        };
    }
    handlerMatching(url) {
        const wrapper = this.handlers.get(url.handlerName);
        if (!wrapper) {
            return undefined;
        }
        return new WorkflowHandler(url.handlerName, this, wrapper);
    }
}
export class WorkflowHandler {
    componentName;
    parent;
    handlerWrapper;
    constructor(componentName, parent, handlerWrapper) {
        this.componentName = componentName;
        this.parent = parent;
        this.handlerWrapper = handlerWrapper;
    }
    name() {
        return this.componentName;
    }
    component() {
        return this.parent;
    }
    kind() {
        return this.handlerWrapper.kind;
    }
    invoke(context, input) {
        return this.handlerWrapper.invoke(context, input);
    }
}
export function parseUrlComponents(urlPath) {
    if (!urlPath) {
        return { type: "unknown", path: "" };
    }
    const fragments = urlPath.split("/");
    if (fragments.length >= 3 && fragments[fragments.length - 3] === "invoke") {
        return {
            type: "invoke",
            componentName: fragments[fragments.length - 2],
            handlerName: fragments[fragments.length - 1],
        };
    }
    if (fragments.length > 0 && fragments[fragments.length - 1] === "discover") {
        return { type: "discover" };
    }
    return { type: "unknown", path: urlPath };
}
//# sourceMappingURL=components.js.map