"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.workflow = exports.object = exports.service = exports.handlers = exports.HandlerWrapper = exports.HandlerKind = exports.makeRpcSendProxy = exports.makeRpcCallProxy = exports.defaultSerde = exports.rpc = exports.SendOpts = exports.Opts = void 0;
const restate_sdk_core_1 = require("@restatedev/restate-sdk-core");
const errors_js_1 = require("./errors.js");
class Opts {
    opts;
    /**
     * Create a call configuration from the provided options.
     *
     * @param opts the call configuration
     */
    static from(opts) {
        return new Opts(opts);
    }
    constructor(opts) {
        this.opts = opts;
    }
    getOpts() {
        return this.opts;
    }
}
exports.Opts = Opts;
class SendOpts {
    opts;
    static from(opts) {
        return new SendOpts(opts);
    }
    getOpts() {
        return this.opts;
    }
    constructor(opts) {
        this.opts = opts;
    }
}
exports.SendOpts = SendOpts;
var rpc;
(function (rpc) {
    rpc.opts = (opts) => Opts.from(opts);
    rpc.sendOpts = (opts) => SendOpts.from(opts);
})(rpc || (exports.rpc = rpc = {}));
function optsFromArgs(args) {
    let parameter;
    let opts;
    switch (args.length) {
        case 0: {
            break;
        }
        case 1: {
            if (args[0] instanceof Opts) {
                opts = args[0].getOpts();
            }
            else if (args[0] instanceof SendOpts) {
                opts = args[0].getOpts();
            }
            else {
                parameter = args[0];
            }
            break;
        }
        case 2: {
            parameter = args[0];
            if (args[1] instanceof Opts) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                opts = args[1].getOpts();
            }
            else if (args[1] instanceof SendOpts) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                opts = args[1].getOpts();
            }
            else {
                throw new TypeError("The second argument must be either Opts or SendOpts");
            }
            break;
        }
        default: {
            throw new TypeError("unexpected number of arguments");
        }
    }
    return {
        parameter,
        opts,
    };
}
const defaultSerde = () => {
    return restate_sdk_core_1.serde.json;
};
exports.defaultSerde = defaultSerde;
const makeRpcCallProxy = (genericCall, service, key) => {
    const clientProxy = new Proxy({}, {
        get: (_target, prop) => {
            const method = prop;
            return (...args) => {
                const { parameter, opts } = optsFromArgs(args);
                const requestSerde = opts?.input ?? (0, exports.defaultSerde)();
                const responseSerde = opts?.output ??
                    (0, exports.defaultSerde)();
                return genericCall({
                    service,
                    method,
                    parameter,
                    key,
                    inputSerde: requestSerde,
                    outputSerde: responseSerde,
                });
            };
        },
    });
    return clientProxy;
};
exports.makeRpcCallProxy = makeRpcCallProxy;
const makeRpcSendProxy = (genericSend, service, key, legacyDelay) => {
    const clientProxy = new Proxy({}, {
        get: (_target, prop) => {
            const method = prop;
            return (...args) => {
                const { parameter, opts } = optsFromArgs(args);
                const requestSerde = opts?.input ?? (0, exports.defaultSerde)();
                const delay = legacyDelay ??
                    opts?.delay;
                return genericSend({
                    service,
                    method,
                    parameter,
                    key,
                    delay,
                    inputSerde: requestSerde,
                });
            };
        },
    });
    return clientProxy;
};
exports.makeRpcSendProxy = makeRpcSendProxy;
// ----------- handlers ----------------------------------------------
var HandlerKind;
(function (HandlerKind) {
    HandlerKind[HandlerKind["SERVICE"] = 0] = "SERVICE";
    HandlerKind[HandlerKind["EXCLUSIVE"] = 1] = "EXCLUSIVE";
    HandlerKind[HandlerKind["SHARED"] = 2] = "SHARED";
    HandlerKind[HandlerKind["WORKFLOW"] = 3] = "WORKFLOW";
})(HandlerKind || (exports.HandlerKind = HandlerKind = {}));
const JSON_CONTENT_TYPE = "application/json";
const HANDLER_SYMBOL = Symbol("Handler");
/** For backward compatability with the serializer handler option */
class SerializerWrapper {
    contentType;
    serializer;
    constructor(contentType, serializer) {
        this.contentType = contentType;
        this.serializer = serializer;
    }
    serialize(input) {
        return this.serializer(input);
    }
    deserialize() {
        throw new Error("Not implemented");
    }
}
/** For backward compatability with the serializer handler option */
class DeserializerWrapper {
    contentType;
    deserializer;
    constructor(contentType, deserializer) {
        this.contentType = contentType;
        this.deserializer = deserializer;
    }
    serialize() {
        throw new Error("Not implemented");
    }
    deserialize(input) {
        return this.deserializer(input);
    }
}
class HandlerWrapper {
    kind;
    handler;
    inputSerde;
    outputSerde;
    static from(kind, handler, opts) {
        // backwards compatibility with the deserializer+accept options
        let inputSerde;
        if (opts?.inputDeserializer) {
            // the caller has specified a custom serializer, use it
            // if the accept is also specified, use it, otherwise use JSON
            inputSerde = new DeserializerWrapper(opts.accept ?? JSON_CONTENT_TYPE, opts.inputDeserializer);
        }
        else if (opts?.accept) {
            // accept but no serializer, use pass trough
            inputSerde = new DeserializerWrapper(opts.accept, (input) => input);
        }
        else if (opts?.contentType === JSON_CONTENT_TYPE) {
            // contentType is JSON, use the default serde
            inputSerde = (0, exports.defaultSerde)();
        }
        else if (opts?.input) {
            // did the caller specify a custom serde?
            inputSerde = opts.input;
        }
        else {
            // use the default (JSON) serde
            inputSerde = (0, exports.defaultSerde)();
        }
        // backwards compatibility with the deserializer handler option
        let outputSerde;
        if (opts?.outputSerializer) {
            outputSerde = new SerializerWrapper(opts.contentType ?? JSON_CONTENT_TYPE, opts.outputSerializer);
        }
        else if (opts?.contentType === JSON_CONTENT_TYPE) {
            // contentType is JSON, use the default serde
            outputSerde = (0, exports.defaultSerde)();
        }
        else if (opts?.contentType) {
            // contentType but no serializer, use passtrough
            outputSerde = new SerializerWrapper(opts.contentType, (input) => input);
        }
        else if (opts?.output) {
            outputSerde = opts.output;
        }
        else {
            outputSerde = (0, exports.defaultSerde)();
        }
        // we must create here a copy of the handler
        // to be able to reuse the original handler in other places.
        // like for example the same logic but under different routes.
        const handlerCopy = function (...args) {
            return handler.apply(this, args);
        };
        return new HandlerWrapper(kind, handlerCopy, inputSerde, outputSerde, opts?.accept);
    }
    static fromHandler(handler) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        return handler[HANDLER_SYMBOL];
    }
    accept;
    contentType;
    constructor(kind, handler, inputSerde, outputSerde, accept) {
        this.kind = kind;
        this.handler = handler;
        this.inputSerde = inputSerde;
        this.outputSerde = outputSerde;
        this.accept = accept ? accept : inputSerde.contentType;
        this.contentType = outputSerde.contentType;
    }
    bindInstance(t) {
        this.handler = this.handler.bind(t);
    }
    async invoke(context, input) {
        let req;
        try {
            req = this.inputSerde.deserialize(input);
        }
        catch (e) {
            throw new errors_js_1.TerminalError(`Failed to deserialize input.`, {
                cause: e,
            });
        }
        const res = await this.handler(context, req);
        return this.outputSerde.serialize(res);
    }
    /**
     * Instead of a HandlerWrapper with a handler property,
     * return the original handler with a HandlerWrapper property.
     * This is needed to keep the appearance of regular functions
     * bound to an object, so that for example, `this.foo(ctx, arg)` would
     * work.
     */
    transpose() {
        const handler = this.handler;
        const existing = HandlerWrapper.fromHandler(handler);
        if (existing !== undefined) {
            return handler;
        }
        Object.defineProperty(handler, HANDLER_SYMBOL, { value: this });
        return handler;
    }
}
exports.HandlerWrapper = HandlerWrapper;
// ----------- handler decorators ----------------------------------------------
var handlers;
(function (handlers) {
    /**
     * Create a service handler.
     *
     * @param opts additional configuration
     * @param fn the actual handler code to execute
     */
    function handler(opts, fn) {
        return HandlerWrapper.from(HandlerKind.SERVICE, fn, opts).transpose();
    }
    handlers.handler = handler;
    let workflow;
    (function (workflow_1) {
        function workflow(optsOrFn, fn) {
            if (typeof optsOrFn === "function") {
                return HandlerWrapper.from(HandlerKind.WORKFLOW, optsOrFn).transpose();
            }
            const opts = optsOrFn;
            if (typeof fn !== "function") {
                throw new TypeError("The second argument must be a function");
            }
            return HandlerWrapper.from(HandlerKind.WORKFLOW, fn, opts).transpose();
        }
        workflow_1.workflow = workflow;
        /**
         * Creates a shared handler for a workflow
         *
         * A shared handler allows a read-only concurrent execution
         * for a given key.
         *
         * @param opts additional configurations
         * @param fn the handler to execute
         */
        function shared(optsOrFn, fn) {
            if (typeof optsOrFn === "function") {
                return HandlerWrapper.from(HandlerKind.SHARED, optsOrFn).transpose();
            }
            const opts = optsOrFn;
            if (typeof fn !== "function") {
                throw new TypeError("The second argument must be a function");
            }
            return HandlerWrapper.from(HandlerKind.SHARED, fn, opts).transpose();
        }
        workflow_1.shared = shared;
    })(workflow = handlers.workflow || (handlers.workflow = {}));
    let object;
    (function (object) {
        /**
         * Creates an exclusive handler for a virtual Object.
         *
         *
         * note 1: This applies only to a virtual object.
         * note 2: This is the default for virtual objects, so if no
         *         additional reconfiguration is needed, you can simply
         *         use the handler directly (no need to use exclusive).
         *         This variant here is only for symmetry/convenance.
         *
         * @param opts additional configurations
         * @param fn the handler to execute
         */
        function exclusive(optsOrFn, fn) {
            if (typeof optsOrFn === "function") {
                return HandlerWrapper.from(HandlerKind.EXCLUSIVE, optsOrFn).transpose();
            }
            const opts = optsOrFn;
            if (typeof fn !== "function") {
                throw new TypeError("The second argument must be a function");
            }
            return HandlerWrapper.from(HandlerKind.EXCLUSIVE, fn, opts).transpose();
        }
        object.exclusive = exclusive;
        /**
         * Creates a shared handler for a virtual Object.
         *
         * A shared handler allows a read-only concurrent execution
         * for a given key.
         *
         * note: This applies only to a virtual object.
         *
         * @param opts additional configurations
         * @param fn the handler to execute
         */
        function shared(optsOrFn, fn) {
            if (typeof optsOrFn === "function") {
                return HandlerWrapper.from(HandlerKind.SHARED, optsOrFn).transpose();
            }
            const opts = optsOrFn;
            if (typeof fn !== "function") {
                throw new TypeError("The second argument must be a function");
            }
            return HandlerWrapper.from(HandlerKind.SHARED, fn, opts).transpose();
        }
        object.shared = shared;
    })(object = handlers.object || (handlers.object = {}));
})(handlers || (exports.handlers = handlers = {}));
/**
 * Define a Restate service.
 *
 * @example Here is an example of how to define a service:
 *
 * ```ts
 *  const greeter = service({
 *    name: "greeter",
 *      handlers: {
 *        greet: async (ctx: Context, name: string) => {
 *          return `Hello ${name}`;
 *        }
 *      }
 * });
 * ```
 *
 * To use the service, you can bind it to an endpoint:
 * ```
 * ...
 * endpoint.bind(greeter)
 * ```
 * @example To use a service, you can export its type to be used in a client:
 * ```
 * export type Greeter = typeof greeter;
 * ...
 * ...
 * import type { Greeter } from "./greeter";
 * const client = ctx.serviceClient<Greeter>({ name : "greeter"});
 * client.greet("World").then(console.log);
 * ```
 *
 * @example Alternatively to avoid repeating the service name, you can:
 * ```
 *  import type {Greeter} from "./greeter";
 *  const Greeter: Greeter = { name : "greeter"};
 *
 *  // now you can reference the service like this:
 *  const client = ctx.serviceClient(Greeter);
 * ```
 *
 * @param name the service name
 * @param handlers the handlers for the service
 * @type P the name of the service
 * @type M the handlers for the service
 */
const service = (service) => {
    if (!service.handlers) {
        throw new Error("service must be defined");
    }
    const handlers = Object.entries(service.handlers).map(([name, handler]) => {
        if (handler instanceof Function) {
            if (HandlerWrapper.fromHandler(handler) !== undefined) {
                return [name, handler];
            }
            return [
                name,
                HandlerWrapper.from(HandlerKind.SERVICE, handler).transpose(),
            ];
        }
        throw new TypeError(`Unexpected handler type ${name}`);
    });
    return {
        name: service.name,
        service: Object.fromEntries(handlers),
    };
};
exports.service = service;
/**
 * Define a Restate virtual object.
 *
 * @example Here is an example of how to define a virtual object:
 * ```ts
 *        const counter = object({
 *            name: "counter",
 *            handlers: {
 *                  add: async (ctx: ObjectContext, amount: number) => {},
 *                  get: async (ctx: ObjectContext) => {}
 *            }
 *        })
 *  ```
 *
 * @example To use the object, you can bind it to an endpoint:
 * ```ts
 * ...
 * endpoint.bind(counter)
 * ```
 *
 *  @see to interact with the object, you can use the object client:
 * ```ts
 * ...
 * const client = ctx.objectClient<typeof counter>({ name: "counter"});
 * const res = await client.add(1)
 * ```
 *
 * ### Shared handlers
 *
 * Shared handlers are used to allow concurrent read-only access to the object.
 * This is useful when you want to allow multiple clients to read the object's state at the same time.
 * To define a shared handler, you can use the `shared` decorator as shown below:
 *
 * ```ts
 *      const counter = object({
 *          name: "counter",
 *          handlers: {
 *
 *            add: async (ctx: ObjectContext, amount: number) => { .. },
 *
 *            get: handlers.object.shared(async (ctx: ObjectSharedContext) => {
 *                  return ctx.get<number>("count");
 *            })
 *       }
 *     });
 * ```
 *
 * @param name the name of the object
 * @param handlers the handlers for the object
 */
const object = (object) => {
    if (!object.handlers) {
        throw new Error("object options must be defined");
    }
    const handlers = Object.entries(object.handlers).map(([name, handler]) => {
        if (handler instanceof Function) {
            if (HandlerWrapper.fromHandler(handler) !== undefined) {
                return [name, handler];
            }
            return [
                name,
                HandlerWrapper.from(HandlerKind.EXCLUSIVE, handler).transpose(),
            ];
        }
        throw new TypeError(`Unexpected handler type ${name}`);
    });
    return {
        name: object.name,
        object: Object.fromEntries(handlers),
    };
};
exports.object = object;
/**
 * Define a Restate workflow.
 *
 *
 * @example Here is an example of how to define a workflow:
 * ```ts
 *      const mywf = workflow({
 *            name: "mywf",
 *            handlers: {
 *                run: async (ctx: WorkflowContext, argument: any) => {
 *                  return "Hello World";
 *                }
 *            }
 *      });
 * ```
 *
 * ### Note:
 * * That a workflow must contain exactly one handler named 'run', and this handler must accept as a first argument a WorkflowContext.
 * * The workflow handlers other than 'run' must accept as a first argument a WorkflowSharedContext.
 * * The workflow handlers can not be named 'workflowSubmit', 'workflowAttach', 'workflowOutput' - as these are reserved keywords.
 *
 * @example To use the workflow, you can bind it to an endpoint:
 * ```ts
 * endpoint.bind(mywf)
 * ```
 *
 * @example To interact with the workflow, you can use the workflow client:
 * ```ts
 * const client = ctx.workflowClient<typeof mywf>({ name: "mywf"});
 * const res = await client.run("Hello");
 * ```
 *
 * To use the workflow client from any other environment (like a browser), please refer to the documentation.
 * https://docs.restate.dev
 *
 *
 *
 * @param name the workflow name
 * @param handlers the handlers for the workflow.
 */
const workflow = (workflow) => {
    if (!workflow.handlers) {
        throw new Error("workflow must contain handlers");
    }
    //
    // Add the main 'run' handler
    //
    const runHandler = workflow.handlers["run"];
    let runWrapper;
    if (runHandler instanceof HandlerWrapper) {
        runWrapper = runHandler;
    }
    else if (runHandler instanceof Function) {
        runWrapper =
            HandlerWrapper.fromHandler(runHandler) ??
                HandlerWrapper.from(HandlerKind.WORKFLOW, runHandler);
    }
    else {
        throw new TypeError(`Missing main workflow handler, named 'run'`);
    }
    if (runWrapper.kind !== HandlerKind.WORKFLOW) {
        throw new TypeError(`Workflow's main handler handler run, must be of type workflow'`);
    }
    const handlers = [["run", runWrapper.transpose()]];
    //
    // Add all the shared handlers now
    //
    for (const [name, handler] of Object.entries(workflow.handlers)) {
        if (name === "run") {
            continue;
        }
        let wrapper;
        if (handler instanceof HandlerWrapper) {
            wrapper = handler;
        }
        else if (handler instanceof Function) {
            wrapper =
                HandlerWrapper.fromHandler(handler) ??
                    HandlerWrapper.from(HandlerKind.SHARED, handler);
        }
        else {
            throw new TypeError(`Unexpected handler type ${name}`);
        }
        if (wrapper.kind === HandlerKind.WORKFLOW) {
            throw new TypeError(`A workflow must contain exactly one handler annotated as workflow, named 'run'. Please use a shared handler for any additional handlers`);
        }
        handlers.push([name, wrapper.transpose()]);
    }
    return {
        name: workflow.name,
        workflow: Object.fromEntries(handlers),
    };
};
exports.workflow = workflow;
//# sourceMappingURL=rpc.js.map